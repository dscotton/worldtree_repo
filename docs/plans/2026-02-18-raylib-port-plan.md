# WorldTree Raylib-cs Port Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Port the Python/PyGame WorldTree platformer to a fully playable C# Raylib-cs (.NET 9) game in `worldtree-raylib/`, preserving all gameplay while using Camera2D for scrolling instead of the Python dual-coordinate system.

**Architecture:** 1:1 Python→C# file mapping (Option A). All entities store world (map) coordinates. Raylib `Camera2D` handles the viewport transform. Map data loaded from JSON files (generated by a Python conversion script). Sounds/textures loaded lazily on first use after Raylib init.

**Tech Stack:** .NET 9, Raylib-cs 6.x (NuGet), xunit 2.x (unit tests), System.Text.Json

**Reference:** See `docs/plans/2026-02-18-raylib-port-design.md` for full design rationale.

---

## Task 1: Project Scaffold ✅

**Files:**
- Create: `worldtree-raylib/WorldTree.sln`
- Create: `worldtree-raylib/src/WorldTree.csproj`
- Create: `worldtree-raylib/tests/WorldTree.Tests.csproj`
- Create: `worldtree-raylib/src/` and `worldtree-raylib/tests/` directories

**Step 1: Create the solution and projects**

```bash
cd /home/dscotton/src/worldtree_repo
mkdir -p worldtree-raylib
cd worldtree-raylib
dotnet new sln -n WorldTree
dotnet new console -n WorldTree -o src --framework net9.0
dotnet new xunit -n WorldTree.Tests -o tests --framework net9.0
dotnet sln add src/WorldTree.csproj
dotnet sln add tests/WorldTree.Tests.csproj
```

**Step 2: Add Raylib-cs to the main project**

```bash
cd src
dotnet add package Raylib-cs --version 6.1.1
```

**Step 3: Add a reference to the main project from tests**

```bash
cd ../tests
dotnet add reference ../src/WorldTree.csproj
```

**Step 4: Create source subdirectory**

```bash
mkdir -p ../src/characters
```

**Step 5: Replace the generated `src/Program.cs` with a stub that opens a window**

```csharp
// src/Program.cs
using Raylib_cs;

Raylib.InitWindow(960, 720, "World Tree");
Raylib.SetTargetFPS(60);
while (!Raylib.WindowShouldClose())
{
    Raylib.BeginDrawing();
    Raylib.ClearBackground(Color.Black);
    Raylib.DrawText("World Tree - Loading...", 100, 350, 24, Color.White);
    Raylib.EndDrawing();
}
Raylib.CloseWindow();
```

**Step 6: Delete the generated test stub in tests/ and replace with a placeholder**

```csharp
// tests/PlaceholderTest.cs
namespace WorldTree.Tests;
public class PlaceholderTest
{
    [Fact]
    public void Placeholder() => Assert.True(true);
}
```

**Step 7: Build and run to verify the window opens**

```bash
cd /home/dscotton/src/worldtree_repo/worldtree-raylib
dotnet build
dotnet run --project src
```
Expected: A 960×720 window titled "World Tree" appears with "World Tree - Loading..." text. Close it with the X button.

**Step 8: Commit**

```bash
cd /home/dscotton/src/worldtree_repo
git add worldtree-raylib/
git commit -m "feat: scaffold Raylib-cs project structure"
```

---

## Task 2: Media Setup ✅

**Files:**
- Create: `worldtree-raylib/media` (symlink)

**Step 1: Create symlink from project media to existing assets**

```bash
cd /home/dscotton/src/worldtree_repo/worldtree-raylib
ln -s ../worldtree/media media
```

**Step 2: Verify the symlink resolves correctly**

```bash
ls media/sprites/beaver10000.png
ls media/music/june_breeze.ogg
ls media/font/PressStart2P.ttf
```
Expected: all three files listed without error.

**Step 3: Commit**

```bash
cd /home/dscotton/src/worldtree_repo
git add worldtree-raylib/media
git commit -m "feat: symlink media assets into raylib project"
```

---

## Task 3: Map Data Conversion ✅

**Files:**
- Create: `worldtree-raylib/convert_maps.py`
- Create: `worldtree-raylib/data/map_data.json`
- Create: `worldtree-raylib/data/map_data2.json`
- Create: `worldtree-raylib/data/map_transitions.json`

**Step 1: Write the conversion script**

```python
# worldtree-raylib/convert_maps.py
"""Converts Python map data to JSON for the C# Raylib port."""

import json
import sys
import os

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'worldtree'))

import map_data
import map_data2
import map_transitions

os.makedirs(os.path.join(os.path.dirname(__file__), 'data'), exist_ok=True)
out = os.path.join(os.path.dirname(__file__), 'data')

with open(os.path.join(out, 'map_data.json'), 'w') as f:
    json.dump(map_data.map_data, f)

with open(os.path.join(out, 'map_data2.json'), 'w') as f:
    json.dump(map_data2.map_data, f)

# Transitions: convert Transition objects to dicts.
# Key structure: { region_str: { room: { direction_str: [ {first,last,region,dest,offset} ] } } }
direction_names = {
    map_transitions.LEFT: 'LEFT',
    map_transitions.RIGHT: 'RIGHT',
    map_transitions.UP: 'UP',
    map_transitions.DOWN: 'DOWN',
}
trans_out = {}
for region, rooms in map_transitions.transitions.items():
    trans_out[str(region)] = {}
    for room, dirs in rooms.items():
        trans_out[str(region)][room] = {}
        for direction, trans_list in dirs.items():
            dir_name = direction_names[direction]
            trans_out[str(region)][room][dir_name] = [
                {'first': t.first, 'last': t.last, 'region': t.region,
                 'dest': t.dest, 'offset': t.offset}
                for t in trans_list
            ]

with open(os.path.join(out, 'map_transitions.json'), 'w') as f:
    json.dump(trans_out, f)

print("Done. Generated data/map_data.json, data/map_data2.json, data/map_transitions.json")
```

**Step 2: Run the script**

```bash
cd /home/dscotton/src/worldtree_repo/worldtree-raylib
python3 convert_maps.py
```
Expected: `Done. Generated data/map_data.json ...`

**Step 3: Verify JSON structure**

```bash
python3 -c "import json; d = json.load(open('data/map_data.json')); m = d['Map1']; print(m['width'], m['height'], m['tileset'], len(m['layout']))"
```
Expected: `50 40 Tiles2 40`

**Step 4: Commit**

```bash
cd /home/dscotton/src/worldtree_repo
git add worldtree-raylib/convert_maps.py worldtree-raylib/data/
git commit -m "feat: add map data conversion script and generated JSON"
```

---

## Task 4: GameConstants.cs ✅

**Files:**
- Create: `worldtree-raylib/src/GameConstants.cs`

**Step 1: Create the file** (direct port of `worldtree/game_constants.py`)

```csharp
// src/GameConstants.cs
using Raylib_cs;

namespace WorldTree;

public static class GameConstants
{
    public const string GameName = "World Tree";
    public const string Font = "PressStart2P.ttf";
    public const int ScreenWidth = 960;
    public const int ScreenHeight = 720;
    public const int MapWidth = 960;
    public const int MapHeight = 640;
    public const int MapX = 0;
    public const int MapY = ScreenHeight - MapHeight;   // 80
    public const int ScrollMarginX = 360;
    public const int ScrollMarginY = 240;
    public const int TileWidth = 48;
    public const int TileHeight = 48;

    public static readonly Color ColorBlack = Color.Black;
    public static readonly Color ColorBlue = new Color(0x10, 0x00, 0x66, 0xFF);
    public static readonly Color ColorWhite = Color.White;
    // Colorkey used in sprites — replaced with transparency at load time
    public static readonly Color SpriteColorkey = new Color(0xFF, 0x00, 0xFF, 0xFF);

    public const string TileDir = "media/tiles";
    public const string MusicDir = "media/music";
    public const string SpritesDir = "media/sprites";
    public const string FontDir = "media/font";
}

// Input action constants
public enum InputAction
{
    Up = 1, Down = 2, Left = 3, Right = 4,
    Jump = 5, Attack = 6, Start = 7, Shoot = 8
}

// Game state — replaces GameOverException / GameWonException
public enum GameState { Playing, GameOver, Won }
```

**Step 2: Build to verify no errors**

```bash
cd /home/dscotton/src/worldtree_repo/worldtree-raylib
dotnet build src
```
Expected: Build succeeded, 0 errors.

**Step 3: Commit**

```bash
git add worldtree-raylib/src/GameConstants.cs
git commit -m "feat: add GameConstants and enums"
```

---

## Task 5: RectangleExtensions.cs ✅

**Files:**
- Create: `worldtree-raylib/src/RectangleExtensions.cs`
- Test: `worldtree-raylib/tests/RectangleExtensionsTests.cs`

These extension methods give Raylib's `Rectangle` the same API the Python code uses.

**Step 1: Write the failing tests first**

```csharp
// tests/RectangleExtensionsTests.cs
using Raylib_cs;
using WorldTree;

namespace WorldTree.Tests;

public class RectangleExtensionsTests
{
    [Fact]
    public void LeftRightTopBottom()
    {
        var r = new Rectangle(10, 20, 30, 40);
        Assert.Equal(10f, r.Left());
        Assert.Equal(40f, r.Right());
        Assert.Equal(20f, r.Top());
        Assert.Equal(60f, r.Bottom());
    }

    [Fact]
    public void Center()
    {
        var r = new Rectangle(10, 20, 30, 40);
        Assert.Equal(25f, r.CenterX());
        Assert.Equal(40f, r.CenterY());
    }

    [Fact]
    public void Move()
    {
        var r = new Rectangle(10, 20, 30, 40);
        var moved = r.Move(5, -3);
        Assert.Equal(15f, moved.X);
        Assert.Equal(17f, moved.Y);
        Assert.Equal(30f, moved.Width);
        Assert.Equal(40f, moved.Height);
    }

    [Fact]
    public void WithSize()
    {
        var r = new Rectangle(10, 20, 30, 40);
        var resized = r.WithSize(60, 80);
        Assert.Equal(10f, resized.X);
        Assert.Equal(20f, resized.Y);
        Assert.Equal(60f, resized.Width);
        Assert.Equal(80f, resized.Height);
    }
}
```

**Step 2: Run tests to verify they fail**

```bash
cd /home/dscotton/src/worldtree_repo/worldtree-raylib
dotnet test tests
```
Expected: Compile error — `Left()` etc. not defined.

**Step 3: Implement the extensions**

```csharp
// src/RectangleExtensions.cs
using Raylib_cs;

namespace WorldTree;

public static class RectangleExtensions
{
    public static float Left(this Rectangle r) => r.X;
    public static float Right(this Rectangle r) => r.X + r.Width;
    public static float Top(this Rectangle r) => r.Y;
    public static float Bottom(this Rectangle r) => r.Y + r.Height;
    public static float CenterX(this Rectangle r) => r.X + r.Width / 2f;
    public static float CenterY(this Rectangle r) => r.Y + r.Height / 2f;

    public static Rectangle Move(this Rectangle r, float dx, float dy) =>
        new Rectangle(r.X + dx, r.Y + dy, r.Width, r.Height);

    public static Rectangle Move(this Rectangle r, (float x, float y) v) =>
        new Rectangle(r.X + v.x, r.Y + v.y, r.Width, r.Height);

    public static Rectangle WithSize(this Rectangle r, float w, float h) =>
        new Rectangle(r.X, r.Y, w, h);

    /// <summary>Returns true if this rectangle overlaps other.</summary>
    public static bool CollideRect(this Rectangle a, Rectangle b) =>
        Raylib.CheckCollisionRecs(a, b);
}
```

**Step 4: Run tests to verify they pass**

```bash
dotnet test tests
```
Expected: All tests pass.

**Step 5: Commit**

```bash
git add worldtree-raylib/src/RectangleExtensions.cs worldtree-raylib/tests/RectangleExtensionsTests.cs
git commit -m "feat: add RectangleExtensions with tests"
```

---

## Task 6: Tile.cs ✅

**Files:**
- Create: `worldtree-raylib/src/Tile.cs`
- Test: `worldtree-raylib/tests/TileTests.cs`

**Step 1: Write the failing tests** (ports the `ParseBoundByte` logic from `tile.py`)

```csharp
// tests/TileTests.cs
using WorldTree;

namespace WorldTree.Tests;

public class TileTests
{
    // ParseBoundByte bit layout (TileStudio format):
    // bit 0 (value 1) = upper (solid_top)
    // bit 1 (value 2) = left  (solid_left)
    // bit 2 (value 4) = lower (solid_bottom)
    // bit 3 (value 8) = right (solid_right)
    [Theory]
    [InlineData(0,  false, false, false, false)]
    [InlineData(15, true,  true,  true,  true)]
    [InlineData(1,  false, false, true,  false)]  // bit 0 = top
    [InlineData(2,  true,  false, false, false)]  // bit 1 = left
    [InlineData(4,  false, false, false, true)]   // bit 2 = bottom... wait, check python
    [InlineData(8,  false, true,  false, false)]  // bit 3 = right
    public void ParseBoundByte_CorrectSolidity(
        byte bound, bool left, bool right, bool top, bool bottom)
    {
        var tile = Tile.FromBoundByte(bound);
        Assert.Equal(left,   tile.SolidLeft);
        Assert.Equal(right,  tile.SolidRight);
        Assert.Equal(top,    tile.SolidTop);
        Assert.Equal(bottom, tile.SolidBottom);
    }

    [Fact]
    public void EmptyTile_NotSolid()
    {
        var tile = Tile.Empty;
        Assert.False(tile.SolidLeft);
        Assert.False(tile.SolidRight);
        Assert.False(tile.SolidTop);
        Assert.False(tile.SolidBottom);
    }
}
```

**Step 2: Run tests to confirm failure**

```bash
dotnet test tests
```
Expected: Compile error — `Tile` not defined.

**Step 3: Implement Tile.cs**

The Python `ParseBoundByte` is: `tuple(bool(x & bound) for x in (2, 8, 1, 4))` → `(solid_left, solid_right, solid_top, solid_bottom)`.
So: left=bit1(2), right=bit3(8), top=bit0(1), bottom=bit2(4).

```csharp
// src/Tile.cs
using Raylib_cs;

namespace WorldTree;

/// <summary>
/// A single map tile. Tiles have no notion of position; the Environment places them.
/// Corresponds to worldtree/tile.py.
/// </summary>
public class Tile
{
    public static readonly Tile Empty = new Tile(null, false, false, false, false);

    public Texture2D? Image { get; }
    public bool SolidLeft   { get; }
    public bool SolidRight  { get; }
    public bool SolidTop    { get; }
    public bool SolidBottom { get; }

    public bool IsEmpty => Image == null && !SolidLeft && !SolidRight && !SolidTop && !SolidBottom;

    public Tile(Texture2D? image, bool solidLeft, bool solidRight, bool solidTop, bool solidBottom)
    {
        Image = image;
        SolidLeft = solidLeft;
        SolidRight = solidRight;
        SolidTop = solidTop;
        SolidBottom = solidBottom;
    }

    /// <summary>
    /// Parse a TileStudio format bound byte into a Tile (without image).
    /// Bit layout: bit0=upper(top), bit1=left, bit2=lower(bottom), bit3=right.
    /// </summary>
    public static Tile FromBoundByte(byte bound)
    {
        bool solidLeft   = (bound & 2) != 0;
        bool solidRight  = (bound & 8) != 0;
        bool solidTop    = (bound & 1) != 0;
        bool solidBottom = (bound & 4) != 0;
        return new Tile(null, solidLeft, solidRight, solidTop, solidBottom);
    }

    public static Tile WithImage(Texture2D image, byte boundByte)
    {
        var proto = FromBoundByte(boundByte);
        return new Tile(image, proto.SolidLeft, proto.SolidRight, proto.SolidTop, proto.SolidBottom);
    }
}
```

**Step 4: Run tests to verify they pass**

```bash
dotnet test tests
```

**Step 5: Commit**

```bash
git add worldtree-raylib/src/Tile.cs worldtree-raylib/tests/TileTests.cs
git commit -m "feat: add Tile with ParseBoundByte and tests"
```

---

## Task 7: Animation.cs ✅

**Files:**
- Create: `worldtree-raylib/src/Animation.cs`
- Test: `worldtree-raylib/tests/AnimationTests.cs`

**Step 1: Write the failing tests**

```csharp
// tests/AnimationTests.cs
using WorldTree;

namespace WorldTree.Tests;

public class AnimationTests
{
    // Stub Texture2D using index as stand-in — Animation doesn't use Raylib
    private static int[] FakeFrames(int count) => Enumerable.Range(0, count).ToArray();

    [Fact]
    public void LoopingAnimation_WrapsAround()
    {
        // framedelay=1: advances every call
        var anim = new Animation<int>([0, 1, 2], frameDelay: 1, looping: true);
        Assert.Equal(0, anim.NextFrame());
        Assert.Equal(1, anim.NextFrame());
        Assert.Equal(2, anim.NextFrame());
        Assert.Equal(0, anim.NextFrame()); // wraps
    }

    [Fact]
    public void NonLoopingAnimation_HoldsLastFrame()
    {
        var anim = new Animation<int>([0, 1, 2], frameDelay: 1, looping: false);
        Assert.Equal(0, anim.NextFrame());
        Assert.Equal(1, anim.NextFrame());
        Assert.Equal(2, anim.NextFrame());
        Assert.Equal(2, anim.NextFrame()); // holds
    }

    [Fact]
    public void FrameDelay_HoldsFrameForMultipleCalls()
    {
        var anim = new Animation<int>([0, 1], frameDelay: 2, looping: true);
        Assert.Equal(0, anim.NextFrame());
        Assert.Equal(0, anim.NextFrame()); // still on 0
        Assert.Equal(1, anim.NextFrame()); // advances on 3rd call
    }

    [Fact]
    public void Reset_GoesBackToStart()
    {
        var anim = new Animation<int>([0, 1, 2], frameDelay: 1, looping: false);
        anim.NextFrame(); anim.NextFrame(); anim.NextFrame(); // advance to end
        anim.Reset();
        Assert.Equal(0, anim.NextFrame());
    }
}
```

**Step 2: Run tests to confirm failure**

```bash
dotnet test tests
```

**Step 3: Implement Animation.cs**

Use a generic type parameter so Animation works with both `Texture2D` (game) and `int` (tests).

```csharp
// src/Animation.cs
namespace WorldTree;

/// <summary>
/// Frame-based animation. Generic so it can be tested without Raylib.
/// Corresponds to worldtree/characters/animation.py.
/// </summary>
public class Animation<T>
{
    private readonly T[] _frames;
    private readonly bool _looping;
    private readonly int _frameDelay;
    private int _current;
    private int _frameCount;

    public Animation(T[] frames, int frameDelay = 2, bool looping = true)
    {
        _frames = frames;
        _frameDelay = frameDelay;
        _looping = looping;
        _current = 0;
        _frameCount = 0;
    }

    public T NextFrame()
    {
        T frame = _frames[_current];
        _frameCount++;
        if (_frameCount == _frameDelay)
        {
            _current++;
            _frameCount = 0;
            if (_current >= _frames.Length)
                _current = _looping ? 0 : _frames.Length - 1;
        }
        return frame;
    }

    public void Reset()
    {
        _current = 0;
        _frameCount = 0;
    }
}
```

**Step 4: Run tests to verify they pass**

```bash
dotnet test tests
```

**Step 5: Commit**

```bash
git add worldtree-raylib/src/Animation.cs worldtree-raylib/tests/AnimationTests.cs
git commit -m "feat: add generic Animation<T> with tests"
```

---

## Task 8: Map Data Types and MapLoader.cs ✅

**Files:**
- Create: `worldtree-raylib/src/MapData.cs`
- Create: `worldtree-raylib/src/MapLoader.cs`
- Test: `worldtree-raylib/tests/MapLoaderTests.cs`

**Step 1: Write the failing tests**

```csharp
// tests/MapLoaderTests.cs
using WorldTree;

namespace WorldTree.Tests;

public class MapLoaderTests
{
    [Fact]
    public void LoadRegion_Map1HasCorrectDimensions()
    {
        var maps = MapLoader.LoadRegion("data/map_data.json");
        Assert.True(maps.ContainsKey("Map1"));
        Assert.Equal(50, maps["Map1"].Width);
        Assert.Equal(40, maps["Map1"].Height);
        Assert.Equal("Tiles2", maps["Map1"].Tileset);
    }

    [Fact]
    public void LoadRegion_LayoutAndBoundsAndMapcodesPresent()
    {
        var maps = MapLoader.LoadRegion("data/map_data.json");
        var m = maps["Map1"];
        Assert.Equal(m.Height, m.Layout.Count);
        Assert.Equal(m.Width, m.Layout[0].Count);
        Assert.Equal(m.Height, m.Bounds.Count);
        Assert.Equal(m.Height, m.Mapcodes.Count);
    }

    [Fact]
    public void LoadTransitions_Region1Map1HasTransitions()
    {
        var trans = MapLoader.LoadTransitions("data/map_transitions.json");
        Assert.True(trans.ContainsKey(1));
        Assert.True(trans[1].ContainsKey("Map1"));
        Assert.True(trans[1]["Map1"].ContainsKey(TransitionDirection.Left));
    }
}
```

**Step 2: Run tests to confirm failure**

```bash
dotnet test tests
```

**Step 3: Implement MapData.cs**

```csharp
// src/MapData.cs
namespace WorldTree;

public class MapInfo
{
    public int Width { get; set; }
    public int Height { get; set; }
    public string Tileset { get; set; } = "";
    public List<List<int>> Layout { get; set; } = [];
    public List<List<int>> Bounds { get; set; } = [];
    public List<List<int>> Mapcodes { get; set; } = [];
}

public class TransitionInfo
{
    public int First { get; set; }
    public int Last { get; set; }
    public int Region { get; set; }
    public string Dest { get; set; } = "";
    public int Offset { get; set; }
}

public enum TransitionDirection { Left, Right, Up, Down }
```

**Step 4: Implement MapLoader.cs**

```csharp
// src/MapLoader.cs
using System.Text.Json;
using System.Text.Json.Nodes;

namespace WorldTree;

public static class MapLoader
{
    public static Dictionary<string, MapInfo> LoadRegion(string jsonPath)
    {
        string json = File.ReadAllText(jsonPath);
        var raw = JsonSerializer.Deserialize<Dictionary<string, JsonElement>>(json)!;
        var result = new Dictionary<string, MapInfo>();
        foreach (var (key, val) in raw)
        {
            result[key] = new MapInfo
            {
                Width    = val.GetProperty("width").GetInt32(),
                Height   = val.GetProperty("height").GetInt32(),
                Tileset  = val.GetProperty("tileset").GetString()!,
                Layout   = DeserializeIntGrid(val.GetProperty("layout")),
                Bounds   = DeserializeIntGrid(val.GetProperty("bounds")),
                Mapcodes = DeserializeIntGrid(val.GetProperty("mapcodes")),
            };
        }
        return result;
    }

    public static Dictionary<int, Dictionary<string, Dictionary<TransitionDirection, List<TransitionInfo>>>>
        LoadTransitions(string jsonPath)
    {
        string json = File.ReadAllText(jsonPath);
        var raw = JsonSerializer.Deserialize<Dictionary<string, JsonElement>>(json)!;
        var result = new Dictionary<int, Dictionary<string, Dictionary<TransitionDirection, List<TransitionInfo>>>>();
        foreach (var (regionStr, regionVal) in raw)
        {
            int region = int.Parse(regionStr);
            result[region] = new();
            foreach (var room in regionVal.EnumerateObject())
            {
                result[region][room.Name] = new();
                foreach (var dir in room.Value.EnumerateObject())
                {
                    var dirEnum = dir.Name switch {
                        "LEFT"  => TransitionDirection.Left,
                        "RIGHT" => TransitionDirection.Right,
                        "UP"    => TransitionDirection.Up,
                        "DOWN"  => TransitionDirection.Down,
                        _ => throw new Exception($"Unknown direction: {dir.Name}")
                    };
                    var list = new List<TransitionInfo>();
                    foreach (var t in dir.Value.EnumerateArray())
                        list.Add(new TransitionInfo {
                            First  = t.GetProperty("first").GetInt32(),
                            Last   = t.GetProperty("last").GetInt32(),
                            Region = t.GetProperty("region").GetInt32(),
                            Dest   = t.GetProperty("dest").GetString()!,
                            Offset = t.GetProperty("offset").GetInt32(),
                        });
                    result[region][room.Name][dirEnum] = list;
                }
            }
        }
        return result;
    }

    private static List<List<int>> DeserializeIntGrid(JsonElement el)
    {
        var rows = new List<List<int>>();
        foreach (var row in el.EnumerateArray())
        {
            var r = new List<int>();
            foreach (var cell in row.EnumerateArray())
                r.Add(cell.GetInt32());
            rows.Add(r);
        }
        return rows;
    }
}
```

**Step 5: Run tests from the project directory (so data/ resolves correctly)**

```bash
cd /home/dscotton/src/worldtree_repo/worldtree-raylib
dotnet test tests
```
Expected: All tests pass.

**Step 6: Commit**

```bash
cd /home/dscotton/src/worldtree_repo
git add worldtree-raylib/src/MapData.cs worldtree-raylib/src/MapLoader.cs worldtree-raylib/tests/MapLoaderTests.cs
git commit -m "feat: add MapData types and MapLoader with JSON parsing"
```

---

## Task 9: TextureCache.cs and Controller.cs ✅

**Files:**
- Create: `worldtree-raylib/src/TextureCache.cs`
- Create: `worldtree-raylib/src/Controller.cs`

No unit tests for these (Controller needs Raylib input; TextureCache needs Raylib GPU).

**Step 1: Implement TextureCache.cs**

This is the C# equivalent of the per-class image caches in the Python code. Call `TextureCache.LoadImages()` where the Python code calls `character.LoadImages()`.

```csharp
// src/TextureCache.cs
using System.Text.RegularExpressions;
using Raylib_cs;

namespace WorldTree;

/// <summary>
/// Loads and caches Texture2D objects. Requires Raylib to be initialized.
/// Corresponds to the LoadImage/LoadImages helpers in worldtree/characters/character.py.
/// </summary>
public static class TextureCache
{
    private static readonly Dictionary<string, Texture2D> _cache = new();

    /// <summary>
    /// Load a single image. 'scaled' means 3x upscale (for sprites).
    /// 'colorkey' means replace #FF00FF with transparency.
    /// </summary>
    public static Texture2D LoadImage(string filename, bool scaled = false, bool colorkey = false)
    {
        string path = Path.Combine(GameConstants.SpritesDir, filename);
        string key = $"{path}|{scaled}|{colorkey}";
        if (_cache.TryGetValue(key, out var cached)) return cached;
        var tex = LoadFromPath(path, scaled, colorkey);
        _cache[key] = tex;
        return tex;
    }

    /// <summary>
    /// Load all images matching a glob pattern (e.g. "beaver1*.png"), sorted alphabetically.
    /// </summary>
    public static Texture2D[] LoadImages(string pattern, bool scaled = false, bool colorkey = false)
    {
        // Convert Python glob to .NET: 'beaver1*.png' → Directory.GetFiles with searchPattern
        string[] files = Directory.GetFiles(GameConstants.SpritesDir, pattern)
                                  .OrderBy(f => f)
                                  .ToArray();
        return files.Select(f => LoadFromPath(f, scaled, colorkey)).ToArray();
    }

    /// <summary>Return a horizontally-flipped copy of a texture (for left/right variants).</summary>
    public static Texture2D FlipHorizontal(Texture2D source)
    {
        Image img = Raylib.LoadImageFromTexture(source);
        Raylib.ImageFlipHorizontal(ref img);
        Texture2D flipped = Raylib.LoadTextureFromImage(img);
        Raylib.UnloadImage(img);
        return flipped;
    }

    /// <summary>Load a tile image scaled to TILE_WIDTH × TILE_HEIGHT.</summary>
    public static Texture2D LoadTile(string path)
    {
        string key = $"tile|{path}";
        if (_cache.TryGetValue(key, out var cached)) return cached;
        Image img = Raylib.LoadImage(path);
        Raylib.ImageResize(ref img, GameConstants.TileWidth, GameConstants.TileHeight);
        Texture2D tex = Raylib.LoadTextureFromImage(img);
        Raylib.UnloadImage(img);
        _cache[key] = tex;
        return tex;
    }

    public static void UnloadAll()
    {
        foreach (var tex in _cache.Values)
            Raylib.UnloadTexture(tex);
        _cache.Clear();
    }

    private static Texture2D LoadFromPath(string path, bool scaled, bool colorkey)
    {
        Image img = Raylib.LoadImage(path);
        if (colorkey)
            Raylib.ImageColorReplace(ref img, GameConstants.SpriteColorkey, Color.Blank);
        if (scaled)
            Raylib.ImageResize(ref img, img.Width * 3, img.Height * 3);
        Texture2D tex = Raylib.LoadTextureFromImage(img);
        Raylib.UnloadImage(img);
        return tex;
    }
}
```

**Step 2: Implement Controller.cs**

```csharp
// src/Controller.cs
using Raylib_cs;

namespace WorldTree;

/// <summary>
/// Maps keyboard input to game actions.
/// Corresponds to worldtree/controller.py.
/// </summary>
public static class Controller
{
    private static readonly Dictionary<KeyboardKey, InputAction> KeyMap = new()
    {
        { KeyboardKey.Up,     InputAction.Up    },
        { KeyboardKey.Down,   InputAction.Down  },
        { KeyboardKey.Left,   InputAction.Left  },
        { KeyboardKey.Right,  InputAction.Right },
        { KeyboardKey.Space,  InputAction.Jump  },
        { KeyboardKey.M,      InputAction.Attack},
        { KeyboardKey.N,      InputAction.Shoot },
        { KeyboardKey.Enter,  InputAction.Start },
        { KeyboardKey.W,      InputAction.Up    },
        { KeyboardKey.A,      InputAction.Left  },
        { KeyboardKey.S,      InputAction.Down  },
        { KeyboardKey.D,      InputAction.Right },
    };

    public static HashSet<InputAction> GetInput()
    {
        var active = new HashSet<InputAction>();
        foreach (var (key, action) in KeyMap)
            if (Raylib.IsKeyDown(key))
                active.Add(action);
        return active;
    }
}
```

**Step 3: Build to verify**

```bash
cd /home/dscotton/src/worldtree_repo/worldtree-raylib
dotnet build src
```

**Step 4: Commit**

```bash
cd /home/dscotton/src/worldtree_repo
git add worldtree-raylib/src/TextureCache.cs worldtree-raylib/src/Controller.cs
git commit -m "feat: add TextureCache and Controller"
```

---

## Task 10: Environment.cs — Construction and Tile Grid

**Files:**
- Create: `worldtree-raylib/src/Environment.cs`

This is the most complex class. Build it in three tasks (10, 11, 12). This task covers construction, tile grid building, and entity group initialisation.

Port of `worldtree/environment.py` — `__init__`, `CreateAreas`.

**Step 1: Create Environment.cs with construction only**

```csharp
// src/Environment.cs
using Raylib_cs;
using System.Numerics;

namespace WorldTree;

/// <summary>
/// A game environment (one room/map).
/// Corresponds to worldtree/environment.py.
/// Entity positions are in world (map) coordinates.
/// </summary>
public class Environment
{
    // Static maps loaded once at startup
    public static Dictionary<int, Dictionary<string, MapInfo>> Regions = new();
    // {region: {room: song_filename}}
    public static Dictionary<int, Dictionary<string, string>> SongsByRoom = new();
    // {region: {room: Color}}
    public static Dictionary<int, Dictionary<string, Color>> BgColorsByRoom = new();

    public string Name { get; }
    public int Region { get; }
    public int Width { get; }   // in tiles
    public int Height { get; }  // in tiles
    public Color BgColor { get; }

    // Tile grid indexed as [col][row]
    private Tile[][] _grid;

    // Entity groups (world coordinates)
    public List<Character> EnemyGroup { get; } = new();
    public List<Character> DyingAnimationGroup { get; } = new();
    public List<Powerup> ItemGroup { get; } = new();
    public List<Projectile> HeroProjectileGroup { get; } = new();
    public List<Projectile> EnemyProjectileGroup { get; } = new();

    public Environment(string mapName, int region)
    {
        Name = mapName;
        Region = region;
        var mapInfo = Regions[region][mapName];
        Width = mapInfo.Width;
        Height = mapInfo.Height;
        BgColor = BgColorsByRoom.TryGetValue(region, out var roomColors)
                  && roomColors.TryGetValue(mapName, out var c) ? c : Color.Black;

        _grid = new Tile[Width][];
        for (int col = 0; col < Width; col++)
            _grid[col] = new Tile[Height];

        BuildTileGrid(mapInfo);
    }

    private void BuildTileGrid(MapInfo mapInfo)
    {
        var imageCache = new Dictionary<string, Texture2D>();
        var areas = new Dictionary<int, List<(int col, int row)>>();

        for (int row = 0; row < Height; row++)
        {
            for (int col = 0; col < Width; col++)
            {
                int tileId = mapInfo.Layout[row][col];
                int boundByte = mapInfo.Bounds[row][col];
                int mapCode = mapInfo.Mapcodes[row][col];

                if (tileId == 0)
                {
                    _grid[col][row] = Tile.Empty;
                }
                else
                {
                    string imageName = $"{mapInfo.Tileset}-{tileId}.png";
                    if (!imageCache.TryGetValue(imageName, out var tex))
                    {
                        tex = TextureCache.LoadTile(
                            Path.Combine(GameConstants.TileDir, imageName));
                        imageCache[imageName] = tex;
                    }
                    _grid[col][row] = Tile.WithImage(tex, (byte)boundByte);
                }

                if (mapCode != 0)
                    SpawnMapCode(mapCode, col, row, areas);
            }
        }

        CreateAreas(areas);
    }

    // Enemy/item spawn codes — mirrors ENEMIES and ITEMS dicts in environment.py
    private static readonly HashSet<int> AreaCodes = new() { 254, 255 };

    private void SpawnMapCode(int mapCode, int col, int row,
        Dictionary<int, List<(int, int)>> areas)
    {
        if (AreaCodes.Contains(mapCode))
        {
            areas.TryAdd(mapCode, new List<(int, int)>());
            areas[mapCode].Add((col, row));
            return;
        }
        var pos = (col, row);
        Character? enemy = mapCode switch
        {
            1  => new Enemies.Beaver(this, pos),
            2  => new Enemies.Dragonfly(this, pos),
            3  => new Enemies.BoomBug(this, pos),
            4  => new Enemies.Shooter(this, pos),
            5  => new Enemies.BugPipe(this, pos),
            6  => new Enemies.PipeBug(this, pos),
            7  => new Enemies.Batzor(this, pos),
            8  => new Enemies.BiterPipe(this, pos),
            9  => new Enemies.Biter(this, pos),
            10 => new Enemies.Slug(this, pos),
            11 => new Enemies.Baron(this, pos),
            _ => null
        };
        if (enemy != null) { EnemyGroup.Add(enemy); return; }

        Powerup? item = mapCode switch
        {
            129 => new Powerups.HealthBoost(this, pos),
            130 => new Powerups.DoubleJump(this, pos),
            131 => new Powerups.MoreSeeds(this, pos),
            _ => null
        };
        if (item != null) { ItemGroup.Add(item); return; }

        throw new Exception($"Unknown mapcode: {mapCode}");
    }

    private void CreateAreas(Dictionary<int, List<(int col, int row)>> areaDict)
    {
        foreach (var (mapCode, coords) in areaDict)
        {
            int i = 0;
            while (i < coords.Count)
            {
                var start = coords[i];
                int width = 1;
                while (i + width < coords.Count
                       && coords[i + width].row == start.row
                       && coords[i + width].col == start.col + width)
                    width++;
                Powerup area = mapCode switch
                {
                    254 => new Powerups.Spike(this, start, width),
                    255 => new Powerups.Lava(this, start, width),
                    _   => throw new Exception($"Unknown area code: {mapCode}")
                };
                ItemGroup.Add(area);
                i += width;
            }
        }
    }

    public Tile GetTile(int col, int row)
    {
        if (col < 0 || col >= Width || row < 0 || row >= Height)
            return Tile.Empty;
        return _grid[col][row];
    }

    // World rect for a tile (used for collision)
    public Rectangle RectForTile(int col, int row) =>
        new Rectangle(col * GameConstants.TileWidth, row * GameConstants.TileHeight,
                      GameConstants.TileWidth - 1, GameConstants.TileHeight - 1);

    public (int col, int row) TileIndexForPoint(float x, float y) =>
        ((int)MathF.Floor(x / GameConstants.TileWidth),
         (int)MathF.Floor(y / GameConstants.TileHeight));

    public bool IsOutsideMap(Rectangle rect)
    {
        var (col, row) = TileIndexForPoint(rect.CenterX(), rect.CenterY());
        return col < 0 || col >= Width || row < 0 || row >= Height;
    }
}
```

**Step 2: Build — expect errors** because `Character`, `Powerup`, `Projectile`, `Enemies`, `Powerups` don't exist yet. That's fine — we'll add forward stubs.

Add temporary stub files so the project builds:

```csharp
// src/characters/Character.cs (stub)
using Raylib_cs;
namespace WorldTree;
public abstract class Character { public Rectangle Rect; public bool IsDead; public abstract void Update(); }
```

```csharp
// src/characters/Powerup.cs (stub)
using Raylib_cs;
namespace WorldTree;
public abstract class Powerup { public Rectangle Rect; public abstract void Update(); }
```

```csharp
// src/characters/Projectile.cs (stub)
using Raylib_cs;
namespace WorldTree;
public abstract class Projectile { public Rectangle Rect; public abstract void Update(); }
```

```csharp
// src/characters/Enemies.cs (stub)
namespace WorldTree;
public static class Enemies {
    public class Beaver(Environment env, (int,int) pos) : Character { public override void Update(){} }
    public class Dragonfly(Environment env, (int,int) pos) : Character { public override void Update(){} }
    public class BoomBug(Environment env, (int,int) pos) : Character { public override void Update(){} }
    public class Shooter(Environment env, (int,int) pos) : Character { public override void Update(){} }
    public class BugPipe(Environment env, (int,int) pos) : Character { public override void Update(){} }
    public class PipeBug(Environment env, (int,int) pos) : Character { public override void Update(){} }
    public class Batzor(Environment env, (int,int) pos) : Character { public override void Update(){} }
    public class BiterPipe(Environment env, (int,int) pos) : Character { public override void Update(){} }
    public class Biter(Environment env, (int,int) pos) : Character { public override void Update(){} }
    public class Slug(Environment env, (int,int) pos) : Character { public override void Update(){} }
    public class Baron(Environment env, (int,int) pos) : Character { public override void Update(){} }
}
```

```csharp
// src/characters/Powerups.cs (stub)
namespace WorldTree;
public static class Powerups {
    public class HealthBoost(Environment env, (int,int) pos) : Powerup { public override void Update(){} }
    public class DoubleJump(Environment env, (int,int) pos) : Powerup { public override void Update(){} }
    public class MoreSeeds(Environment env, (int,int) pos) : Powerup { public override void Update(){} }
    public class Spike(Environment env, (int,int) pos, int width) : Powerup { public override void Update(){} }
    public class Lava(Environment env, (int,int) pos, int width) : Powerup { public override void Update(){} }
}
```

```bash
dotnet build src
```
Expected: Build succeeded.

**Step 3: Commit**

```bash
git add worldtree-raylib/src/
git commit -m "feat: add Environment construction and tile grid"
```

---

## Task 11: Environment.cs — Camera and Rendering

**Files:**
- Modify: `worldtree-raylib/src/Environment.cs`

Add Camera2D management, scrolling, tile rendering, and entity draw calls.

**Step 1: Add these members and methods to Environment.cs**

```csharp
// Add to Environment class:

// Camera state (replaces screen_offset in Python)
public Vector2 ScreenOffset { get; private set; } = Vector2.Zero;

public Camera2D MakeCamera() => new Camera2D
{
    Offset = new Vector2(GameConstants.MapX, GameConstants.MapY),
    Target = ScreenOffset,
    Rotation = 0f,
    Zoom = 1f
};

/// <summary>
/// Update the camera to follow rect (world coords). Returns updated camera.
/// Replaces Environment.Scroll() in Python — no need to apply scroll_vector to entities
/// because all entities are already in world coordinates.
/// </summary>
public Camera2D Scroll(Camera2D camera, Rectangle rect)
{
    var offset = ScreenOffset;
    float mapPixelW = Width  * GameConstants.TileWidth;
    float mapPixelH = Height * GameConstants.TileHeight;

    if (rect.CenterX() < offset.X + GameConstants.ScrollMarginX && offset.X > 0)
        offset.X = MathF.Max(0, rect.CenterX() - GameConstants.ScrollMarginX);
    else if (rect.CenterX() > offset.X + GameConstants.MapWidth - GameConstants.ScrollMarginX
             && offset.X + GameConstants.MapWidth < mapPixelW)
        offset.X = MathF.Min(mapPixelW - GameConstants.MapWidth,
                             rect.CenterX() - (GameConstants.MapWidth - GameConstants.ScrollMarginX));

    if (rect.CenterY() < offset.Y + GameConstants.ScrollMarginY && offset.Y > 0)
        offset.Y = MathF.Max(0, rect.CenterY() - GameConstants.ScrollMarginY);
    else if (rect.CenterY() > offset.Y + GameConstants.MapHeight - GameConstants.ScrollMarginY
             && offset.Y + GameConstants.MapHeight < mapPixelH)
        offset.Y = MathF.Min(mapPixelH - GameConstants.MapHeight,
                             rect.CenterY() - (GameConstants.MapHeight - GameConstants.ScrollMarginY));

    ScreenOffset = offset;
    camera.Target = offset;
    return camera;
}

/// <summary>Set initial camera offset (e.g. on room transition).</summary>
public void SetScreenOffset(float x, float y) =>
    ScreenOffset = new Vector2(
        Math.Clamp(x, 0, Width  * GameConstants.TileWidth  - GameConstants.MapWidth),
        Math.Clamp(y, 0, Height * GameConstants.TileHeight - GameConstants.MapHeight));

/// <summary>
/// Draw the visible tiles. Call this inside BeginMode2D / EndMode2D.
/// </summary>
public void DrawTiles()
{
    int firstCol = (int)(ScreenOffset.X / GameConstants.TileWidth);
    int lastCol  = firstCol + GameConstants.MapWidth  / GameConstants.TileWidth + 1;
    int firstRow = (int)(ScreenOffset.Y / GameConstants.TileHeight);
    int lastRow  = firstRow + GameConstants.MapHeight / GameConstants.TileHeight + 1;

    for (int col = firstCol; col <= Math.Min(lastCol, Width - 1); col++)
        for (int row = firstRow; row <= Math.Min(lastRow, Height - 1); row++)
        {
            var tile = _grid[col][row];
            if (tile == Tile.Empty || tile.Image == null) continue;
            Raylib.DrawTexture(tile.Image.Value,
                col * GameConstants.TileWidth,
                row * GameConstants.TileHeight,
                Color.White);
        }
}

public bool IsWorldPointVisible(float x, float y) =>
    x >= ScreenOffset.X && x <= ScreenOffset.X + GameConstants.MapWidth &&
    y >= ScreenOffset.Y && y <= ScreenOffset.Y + GameConstants.MapHeight;
```

**Step 2: Build to verify**

```bash
dotnet build src
```

**Step 3: Commit**

```bash
git commit -am "feat: add Environment camera, scroll, and tile rendering"
```

---

## Task 12: Environment.cs — Collision

**Files:**
- Modify: `worldtree-raylib/src/Environment.cs`

Port `AttemptMove`, `IsMoveLegal`, `TilesForRect`, `IsRectSupported`, `IsTileSupported`.
All rects are now in world coordinates — no coordinate conversion needed.

**Step 1: Add collision methods to Environment.cs**

```csharp
// Add to Environment class:

/// <summary>
/// Check which tile grid cells a world-coordinate rect intersects.
/// </summary>
public List<(int col, int row)> TilesForRect(Rectangle rect)
{
    int left  = (int)MathF.Floor(rect.Left()  / GameConstants.TileWidth);
    int right = (int)MathF.Floor(rect.Right() / GameConstants.TileWidth);
    int top   = (int)MathF.Floor(rect.Top()   / GameConstants.TileHeight);
    int bot   = (int)MathF.Floor(rect.Bottom()/ GameConstants.TileHeight);
    var result = new List<(int, int)>();
    for (int c = left; c <= right; c++)
        for (int r = top; r <= bot; r++)
            result.Add((c, r));
    return result;
}

/// <summary>
/// Attempt a move, blocking per-tile-side solidity. Returns new world rect.
/// For player (isPlayer=true), allows moving off map edges for room transitions.
/// </summary>
public Rectangle AttemptMove(Rectangle hitbox, (float x, float y) vector, bool isPlayer = false)
{
    var dest = hitbox.Move(vector.x, vector.y);
    float newVX = vector.x, newVY = vector.y;

    var oldTiles = new HashSet<(int, int)>(TilesForRect(hitbox));
    var newTiles = TilesForRect(dest).Where(t => !oldTiles.Contains(t));

    foreach (var (col, row) in newTiles)
    {
        Tile square;
        if (col < 0 || col >= Width || row < 0 || row >= Height)
            square = isPlayer ? new Tile(null,false,false,false,false)
                              : new Tile(null,true, true, true, true);
        else
            square = _grid[col][row];

        var tileRect = RectForTile(col, row);

        if (hitbox.Bottom() < tileRect.Top() && square.SolidTop
            && dest.Bottom() >= tileRect.Top())
            newVY = tileRect.Top() - hitbox.Bottom() - 1;
        else if (hitbox.Top() > tileRect.Bottom() && square.SolidBottom
                 && dest.Top() <= tileRect.Bottom())
            newVY = tileRect.Bottom() - hitbox.Top() + 1;

        if (hitbox.Right() < tileRect.Left() && square.SolidLeft
            && dest.Right() >= tileRect.Left())
            newVX = tileRect.Left() - hitbox.Right() - 1;
        else if (hitbox.Left() > tileRect.Right() && square.SolidRight
                 && dest.Left() <= tileRect.Right())
            newVX = tileRect.Right() - hitbox.Left() + 1;
    }

    return hitbox.Move(newVX, newVY);
}

/// <summary>
/// Simplified collision check for projectiles — off-map is illegal.
/// </summary>
public bool IsMoveLegal(Rectangle hitbox, (float x, float y) vector)
{
    var dest = hitbox.Move(vector.x, vector.y);
    var oldTiles = new HashSet<(int, int)>(TilesForRect(hitbox));
    foreach (var (col, row) in TilesForRect(dest).Where(t => !oldTiles.Contains(t)))
    {
        Tile square;
        if (col < 0 || col >= Width || row < 0 || row >= Height)
            square = new Tile(null, true, true, true, true);
        else
            square = _grid[col][row];

        var tileRect = RectForTile(col, row);

        if (hitbox.Bottom() < tileRect.Top() && square.SolidTop && dest.Bottom() >= tileRect.Top())
            return false;
        if (hitbox.Top() > tileRect.Bottom() && square.SolidBottom && dest.Top() <= tileRect.Bottom())
            return false;
        if (hitbox.Right() < tileRect.Left() && square.SolidLeft && dest.Right() >= tileRect.Left())
            return false;
        if (hitbox.Left() > tileRect.Right() && square.SolidRight && dest.Left() <= tileRect.Right())
            return false;
    }
    return true;
}

/// <summary>
/// Returns true if there is a solid tile in the direction of vector from rect.
/// </summary>
public bool IsRectSupported(Rectangle rect, (float x, float y) vector = default)
{
    if (vector == default) vector = (0, 1);
    var dest = rect.Move(vector.x, vector.y);
    var oldTiles = new HashSet<(int, int)>(TilesForRect(rect));
    foreach (var (col, row) in TilesForRect(dest).Where(t => !oldTiles.Contains(t)))
    {
        if (col < 0 || col >= Width) continue;
        if (row < 0) return false;
        if (row >= Height) return true;
        if (_grid[col][row].SolidTop) return true;
    }
    return false;
}

public bool IsTileSupported(int col, int row) =>
    IsRectSupported(RectForTile(col, row));
```

**Step 2: Build to verify**

```bash
dotnet build src
```

**Step 3: Commit**

```bash
git commit -am "feat: add Environment collision methods"
```

---

## Task 13: Character.cs — Base Class

**Files:**
- Replace stub: `worldtree-raylib/src/characters/Character.cs`

Port of `worldtree/characters/character.py`. Entities live in world coordinates throughout.

**Step 1: Replace stub with full implementation**

```csharp
// src/characters/Character.cs
using Raylib_cs;
using System.Numerics;

namespace WorldTree;

public enum CharacterAction { Stand = 1, Walk = 2, Run = 3, Jump = 4, Fall = 5, Grounded = 6 }
public enum Direction { Left = 3, Right = 4 }

/// <summary>
/// Abstract base for all game characters (player, enemies).
/// All positions are in world (map) coordinates.
/// Corresponds to worldtree/characters/character.py.
/// </summary>
public abstract class Character
{
    // --- Constants (override in subclasses) ---
    public virtual int StartingHp => 1;
    public virtual bool IsInvulnerable => false;
    public virtual int InvulnerabilityFrames => 30;
    public virtual float Gravity => 2f;
    public virtual float TerminalVelocity => 10f;
    public virtual float Accel => 100f;
    public virtual float Speed => 0f;
    public virtual int JumpDuration => 0;
    public virtual int Width => 48;
    public virtual int Height => 48;
    public virtual float PushBack => 16f;
    public virtual int Damage => 0;
    public virtual bool IsPlayer => false;

    // --- State ---
    public Rectangle Rect;       // world coordinates
    public bool IsDead { get; private set; }
    public int Hp { get; protected set; }
    public int MaxHp { get; protected set; }
    public int Invulnerable { get; protected set; }
    public CharacterAction Action { get; protected set; } = CharacterAction.Stand;
    public Direction Facing { get; protected set; } = Direction.Left;
    public CharacterAction Vertical { get; protected set; } = CharacterAction.Fall;
    protected Vector2 Movement;
    protected int JumpFrames;
    protected Environment Env;
    protected Texture2D CurrentImage;

    // Sounds (lazy-loaded after Raylib init)
    private static Sound? _hitSound;
    private static Sound? _deathSound;
    protected static Sound HitSound => _hitSound ??= Raylib.LoadSound("media/sfx/hit.wav");
    protected static Sound DeathSound => _deathSound ??= Raylib.LoadSound("media/sfx/death.wav");

    protected Character(Environment env, (int col, int row) position)
    {
        Env = env;
        Hp = MaxHp = StartingHp;
        var tileRect = env.RectForTile(position.col, position.row);
        // Align bottom of character to bottom of tile (matching Python behaviour)
        Rect = new Rectangle(tileRect.X, tileRect.Bottom() - Height, Width, Height);
        InitImages();
    }

    protected abstract void InitImages();
    protected abstract void SetCurrentImage();

    // Hitbox for collision — slightly inset from Rect (all in world coords)
    public virtual Rectangle Hitbox() =>
        new Rectangle(Rect.X + 1, Rect.Y + 1, Rect.Width - 2, Rect.Height - 2);

    // Fallbox for gravity — same as Hitbox by default
    public virtual Rectangle Fallbox() => Hitbox();

    // Draw the character (called inside BeginMode2D)
    public virtual void Draw()
    {
        float alpha = (Invulnerable > 0 && Invulnerable % 4 > 0) ? 128 : 255;
        var tint = new Color(255, 255, 255, (byte)alpha);
        Raylib.DrawTexture(CurrentImage, (int)Rect.X, (int)Rect.Y, tint);
    }

    protected void Walk(Direction dir)
    {
        if (Action != CharacterAction.Jump) Action = CharacterAction.Walk;
        Facing = dir;
        if (dir == Direction.Left)
            Movement.X = Movement.X < -Speed ? Movement.X + Gravity : MathF.Max(Movement.X - Accel, -Speed);
        else
            Movement.X = Movement.X > Speed ? Movement.X - Gravity : MathF.Min(Movement.X + Accel, Speed);
    }

    protected void ApplyGravity()
    {
        if (Movement.Y < TerminalVelocity)
            Movement.Y = MathF.Min(Movement.Y + Gravity, TerminalVelocity);
    }

    protected virtual void Supported()
    {
        Vertical = CharacterAction.Grounded;
        Movement.Y = 0;
    }

    protected abstract (float x, float y) GetMove();

    public virtual void Update()
    {
        var move = GetMove();
        var newHitbox = Env.AttemptMove(Hitbox(), move, IsPlayer);
        // Reposition Rect so that Hitbox() matches newHitbox
        Rect = new Rectangle(newHitbox.X - 1, newHitbox.Y - 1,
                              Rect.Width, Rect.Height);
        if (Env.IsRectSupported(Fallbox()))
            Supported();
        else
            ApplyGravity();

        SetCurrentImage();
        if (Invulnerable > 0) Invulnerable--;
        if (Env.IsOutsideMap(Hitbox())) Kill();
    }

    public virtual void TakeHit(int damage)
    {
        Raylib.PlaySound(HitSound);
        Hp -= damage;
        if (Hp <= 0) Die();
        else Invulnerable = InvulnerabilityFrames;
    }

    public virtual void Die()
    {
        Raylib.PlaySound(DeathSound);
        DropItem();
        Env.DyingAnimationGroup.Add(new DyingAnimation(Rect));
        Kill();
    }

    protected virtual void DropItem()
    {
        // Subclasses override to configure drops
    }

    public void Kill() => IsDead = true;

    public float GetDistance(Character other) =>
        Vector2.Distance(new Vector2(Hitbox().CenterX(), Hitbox().CenterY()),
                         new Vector2(other.Hitbox().CenterX(), other.Hitbox().CenterY()));

    public void CollisionPushback(Character other)
    {
        float dx = Rect.CenterX() - other.Rect.CenterX();
        float dy = Rect.CenterY() - other.Rect.CenterY();
        float scalar = other.PushBack / MathF.Sqrt(dx * dx + dy * dy);
        Movement.X += (int)(dx * scalar);
        Movement.Y += (int)(dy * scalar);
    }

    protected (float x, float y) WalkBackAndForth()
    {
        Walk(Facing);
        int checkX = Facing == Direction.Left
            ? (int)(Hitbox().Left() + Movement.X)
            : (int)(Hitbox().Right() + Movement.X);
        var destTile = Env.TileIndexForPoint(checkX, Hitbox().Bottom());
        if (!Env.IsMoveLegal(Hitbox(), (Movement.X, Movement.Y))
            || !Env.IsTileSupported(destTile.col, destTile.row))
        {
            Facing = Facing == Direction.Left ? Direction.Right : Direction.Left;
        }
        return (Movement.X, Movement.Y);
    }

    public void RecoverHealth(int amount) => Hp = Math.Min(MaxHp, Hp + amount);
    public void RaiseMaxHp(int amount) { MaxHp += amount; RecoverHealth(amount); }
}

/// <summary>
/// Dying explosion animation. Corresponds to the Dying class in character.py.
/// </summary>
public class DyingAnimation
{
    private static Texture2D[]? _images;
    private Animation<Texture2D> _animation;
    public Rectangle Rect;
    public bool IsDead { get; private set; }
    private int _frames = 20;
    private bool _isPlayer;
    private bool _isBoss;
    private Sound? _endSound;

    private static Texture2D[] Images => _images ??=
        TextureCache.LoadImages("regularexplode1*.png", scaled: true,
                                colorkey: true);

    public DyingAnimation(Rectangle sourceRect, bool isPlayer = false,
                          bool isBoss = false, Sound? endSound = null)
    {
        _animation = new Animation<Texture2D>(Images, frameDelay: 3, looping: false);
        Rect = new Rectangle(0, 0, Images[0].Width, Images[0].Height);
        Rect.X = sourceRect.CenterX() - Rect.Width / 2f;
        Rect.Y = sourceRect.CenterY() - Rect.Height / 2f;
        _isPlayer = isPlayer;
        _isBoss = isBoss;
        _endSound = endSound;
        if (isPlayer || isBoss)
        {
            Raylib.StopMusicStream(default); // music stop handled by caller
            if (endSound.HasValue) Raylib.PlaySound(endSound.Value);
        }
    }

    public GameState Update()
    {
        _frames--;
        if (_frames <= 0)
        {
            IsDead = true;
            if (_isPlayer) return GameState.GameOver;
            if (_isBoss)   return GameState.Won;
        }
        return GameState.Playing;
    }

    public void Draw()
    {
        var tex = _animation.NextFrame();
        Raylib.DrawTexture(tex, (int)Rect.X, (int)Rect.Y, Color.White);
    }
}
```

**Step 2: Build**

```bash
dotnet build src
```

**Step 3: Commit**

```bash
git commit -am "feat: add Character base class and DyingAnimation"
```

---

## Task 14: Projectile.cs

**Files:**
- Replace stub: `worldtree-raylib/src/characters/Projectile.cs`

Port of `worldtree/characters/projectile.py`.

**Step 1: Replace stub with full implementation**

```csharp
// src/characters/Projectile.cs
using Raylib_cs;
using System.Numerics;

namespace WorldTree;

public abstract class Projectile
{
    public Rectangle Rect;  // world coords
    public bool IsDead { get; protected set; }
    protected Environment Env;
    protected int _damage;
    protected Vector2 _movement;
    protected Texture2D _currentImage;

    protected Projectile(Environment env, int damage, float speed,
                         (float x, float y) direction, (float x, float y) position)
    {
        Env = env;
        _damage = damage;
        float mag = MathF.Sqrt(direction.x * direction.x + direction.y * direction.y);
        _movement = new Vector2(direction.x / mag * speed, direction.y / mag * speed);
        InitImages();
        Rect = new Rectangle(position.x, position.y, _currentImage.Width, _currentImage.Height);
    }

    protected abstract void InitImages();
    protected virtual void SetCurrentImage() { }

    public Rectangle Hitbox() => Rect;

    public virtual void CollideWith(Character sprite)
    {
        if (sprite.Invulnerable == 0)
            sprite.TakeHit(_damage);
    }

    public virtual void Update()
    {
        SetCurrentImage();
        if (!Env.IsMoveLegal(Rect, (_movement.X, _movement.Y)))
        { IsDead = true; return; }
        Rect = Rect.Move(_movement.X, _movement.Y);
    }

    public void Draw() =>
        Raylib.DrawTexture(_currentImage, (int)Rect.X, (int)Rect.Y, Color.White);
}

public class SeedBullet : Projectile
{
    private const int SeedDamage = 4;
    private const float SeedSpeed = 12f;
    private static Texture2D[]? _images;
    private Animation<Texture2D> _anim;

    private static Texture2D[] Images => _images ??=
        TextureCache.LoadImages("seedprojectile*.png", scaled: true, colorkey: true);

    public SeedBullet(Environment env, (float x, float y) direction, (float x, float y) position)
        : base(env, SeedDamage, SeedSpeed, direction, position) { }

    protected override void InitImages()
    {
        _anim = new Animation<Texture2D>(Images, frameDelay: 5);
        _currentImage = _anim.NextFrame();
    }

    protected override void SetCurrentImage() => _currentImage = _anim.NextFrame();
}

public class SporeCloud : Projectile
{
    private const int SporeDamage = 2;
    private const float SporeSpeed = 3f;
    private static Texture2D? _image;

    private static Texture2D Image => _image ??=
        TextureCache.LoadImage("spore0000.png", scaled: true, colorkey: true);

    public SporeCloud(Environment env, (float x, float y) direction, (float x, float y) position)
        : base(env, SporeDamage, SporeSpeed, direction, position)
    {
        Rect = Rect.Move(_movement.X * 5, _movement.Y * 15);
    }

    protected override void InitImages() => _currentImage = Image;
}
```

**Step 2: Build and commit**

```bash
dotnet build src
git commit -am "feat: add Projectile, SeedBullet, SporeCloud"
```

---

## Task 15: Hero.cs

**Files:**
- Create: `worldtree-raylib/src/characters/Hero.cs`

Port of `worldtree/characters/hero.py`.

**Step 1: Implement Hero.cs**

```csharp
// src/characters/Hero.cs
using Raylib_cs;
using System.Numerics;

namespace WorldTree;

public class Hero : Character
{
    public override int StartingHp => 30;
    public override int Damage => 2;
    public override int Width => 72;
    public override int Height => 96;
    public override float Accel => 2f;
    public override float Speed => 5f;
    public override float Gravity => 2f;
    public override float TerminalVelocity => 10f;
    public override int InvulnerabilityFrames => 120;
    public override bool IsPlayer => true;

    private const int StandWidth = 47;
    private const int AttackDuration = 30;
    private const int ShootingCooldown = 30;
    private const int HitboxLeftOffset = -20;
    private const int HitboxRightOffset = 19;
    private const int JumpForce = 10;
    private const int JumpDurationConst = 22;

    // Sprite state
    private Animation<Texture2D>? _walkRight, _walkLeft, _attackRight, _attackLeft;
    private Texture2D _standRight, _standLeft, _jumpRight, _jumpLeft, _fallRight, _fallLeft;

    // Sounds
    private static Sound? _attackSound, _jumpSound, _deathSoundField;
    private static Sound AttackSoundAsset => _attackSound ??= Raylib.LoadSound("media/sfx/attack.wav");
    private static Sound JumpSoundAsset   => _jumpSound   ??= Raylib.LoadSound("media/sfx/jump.wav");
    private static Sound HeroDeathSound   => _deathSoundField ??= Raylib.LoadSound("media/music/game_over.ogg");

    // Game state
    public int MaxJumps { get; set; } = 1;
    private int _remainingJumps;
    private bool _jumpReady = true;
    private bool _attackReady = true;
    private int _attacking;
    private int _shootingCooldown;
    public int Ammo { get; set; }
    public int MaxAmmo { get; set; }

    public Hero(Environment env, (int col, int row) position) : base(env, position)
    {
        _remainingJumps = MaxJumps;
    }

    protected override void InitImages()
    {
        var walkImgs = TextureCache.LoadImages("treeguywalk*.png", scaled: true, colorkey: true);
        _walkRight = new Animation<Texture2D>(walkImgs);
        _walkLeft  = new Animation<Texture2D>(walkImgs.Select(TextureCache.FlipHorizontal).ToArray());

        _standRight = TextureCache.LoadImage("treeguyidle0000.png", scaled: true, colorkey: true);
        _standLeft  = TextureCache.FlipHorizontal(_standRight);
        _jumpRight  = TextureCache.LoadImage("treeguyjump0000.png", scaled: true, colorkey: true);
        _jumpLeft   = TextureCache.FlipHorizontal(_jumpRight);
        _fallRight  = TextureCache.LoadImage("treeguyfall0000.png", scaled: true, colorkey: true);
        _fallLeft   = TextureCache.FlipHorizontal(_fallRight);

        var atkImgs = TextureCache.LoadImages("treeguystrikefollow*.png", scaled: true, colorkey: true);
        _attackRight = new Animation<Texture2D>(atkImgs, looping: false);
        _attackLeft  = new Animation<Texture2D>(atkImgs.Select(TextureCache.FlipHorizontal).ToArray(), looping: false);

        CurrentImage = _walkRight!.NextFrame();
    }

    public override Rectangle Hitbox()
    {
        if (_attacking > 0)
            return new Rectangle(Rect.X + 1, Rect.Y + 1, Rect.Width - 2, Rect.Height - 2);
        return Facing == Direction.Left
            ? new Rectangle(Rect.X + 10, Rect.Y + 1, 50, Rect.Height - 2)
            : new Rectangle(Rect.X + 10, Rect.Y + 1, 52, Rect.Height - 2);
    }

    public override Rectangle Fallbox()
    {
        return Facing == Direction.Left
            ? new Rectangle(Rect.X + HitboxLeftOffset + Rect.Width - StandWidth, Rect.Y + 1,
                            StandWidth, Rect.Height - 2)
            : new Rectangle(Rect.X + HitboxRightOffset, Rect.Y + 1,
                            StandWidth, Rect.Height - 2);
    }

    public void HandleInput()
    {
        var actions = Controller.GetInput();
        if (_attacking > 0) StopMoving();
        bool goLeft  = actions.Contains(InputAction.Left);
        bool goRight = actions.Contains(InputAction.Right);
        if ((!goLeft && !goRight) || (goLeft && goRight)) StopMoving();
        else if (goLeft  && (Vertical != CharacterAction.Grounded || _attacking == 0)) Walk(Direction.Left);
        else if (goRight && (Vertical != CharacterAction.Grounded || _attacking == 0)) Walk(Direction.Right);

        if (actions.Contains(InputAction.Jump)) { DoJump(); _jumpReady = false; }
        else { StopUpwardMovement(); _jumpReady = true; }

        if (actions.Contains(InputAction.Attack) && _attacking <= 0) { Attack(); _attackReady = false; }
        else if (actions.Contains(InputAction.Shoot) && _attacking <= 0
                 && _shootingCooldown <= 0 && Ammo > 0) Shoot();
        else _attackReady = true;

        if (_attacking > 0) { _attacking--; if (_attacking == 0) ResetAnimations(); }
    }

    private void StopMoving()
    {
        if (Movement.X > 0) Movement.X = MathF.Max(Movement.X - Gravity, 0);
        else if (Movement.X < 0) Movement.X = MathF.Min(Movement.X + Gravity, 0);
        if (Vertical != CharacterAction.Jump && _attacking == 0 && Movement.X == 0)
            Action = CharacterAction.Stand;
    }

    private void StopUpwardMovement()
    {
        if (Vertical == CharacterAction.Jump) { Vertical = CharacterAction.Fall; JumpFrames = 0; }
    }

    private void DoJump()
    {
        if (_jumpReady && _remainingJumps > 0)
        {
            Raylib.PlaySound(JumpSoundAsset);
            Vertical = CharacterAction.Jump;
            _remainingJumps--;
            JumpFrames = JumpDurationConst;
            Movement.Y = -JumpForce;
        }
        else if (Vertical == CharacterAction.Jump)
        {
            JumpFrames--;
            if (JumpFrames == 0) Vertical = CharacterAction.Fall;
        }
    }

    protected override void Supported()
    {
        Vertical = CharacterAction.Grounded;
        _remainingJumps = MaxJumps;
        Movement.Y = Math.Min(0, Movement.Y);
    }

    private void Attack()
    {
        if (_attackReady) { Raylib.PlaySound(AttackSoundAsset); _attacking = AttackDuration; }
    }

    private void Shoot()
    {
        Ammo--;
        _shootingCooldown = ShootingCooldown;
        var dir = Facing == Direction.Left ? (-1f, 0f) : (1f, 0f);
        var pos = Facing == Direction.Left
            ? (Rect.Left() - 8, Rect.CenterY() - 32)
            : (Rect.Right(),    Rect.CenterY() - 32);
        Env.HeroProjectileGroup.Add(new SeedBullet(Env, dir, pos));
    }

    private void ResetAnimations()
    {
        _attackLeft?.Reset(); _attackRight?.Reset();
    }

    protected override (float x, float y) GetMove() => (Movement.X, Movement.Y);

    protected override void SetCurrentImage()
    {
        var prev = Rect;
        var prevFallbox = Fallbox();

        CurrentImage = (Facing, _attacking > 0, Vertical, Action) switch
        {
            (Direction.Left,  true,  _, _) => _attackLeft!.NextFrame(),
            (Direction.Right, true,  _, _) => _attackRight!.NextFrame(),
            (Direction.Left,  false, CharacterAction.Jump, _) => _jumpLeft,
            (Direction.Right, false, CharacterAction.Jump, _) => _jumpRight,
            (Direction.Left,  false, CharacterAction.Fall, _) => _fallLeft,
            (Direction.Right, false, CharacterAction.Fall, _) => _fallRight,
            (Direction.Left,  false, _, CharacterAction.Walk) => _walkLeft!.NextFrame(),
            (Direction.Right, false, _, CharacterAction.Walk) => _walkRight!.NextFrame(),
            (Direction.Left,  false, _, _) => _standLeft,
            _ => _standRight,
        };
        Rect = Rect.WithSize(CurrentImage.Width, Rect.Height);

        // Realign fallbox to same world position after width change
        var newFallbox = Fallbox();
        float diffX = Facing == Direction.Left
            ? prevFallbox.Right()  - newFallbox.Right()
            : prevFallbox.Left()   - newFallbox.Left();
        Rect = Rect.Move(diffX, prevFallbox.Top() - newFallbox.Top());
    }

    public override void Update()
    {
        SetCurrentImage();
        var newHitbox = Env.AttemptMove(Fallbox(), (Movement.X, Movement.Y), isPlayer: true);
        // Camera scroll happens in Program.cs — hero update returns movement only
        Rect = Rect.Move(newHitbox.X - Fallbox().X, newHitbox.Y - Fallbox().Y);

        bool supported = Env.IsRectSupported(Fallbox())
                      || Env.IsRectSupported(Fallbox().Move(Movement.X, 0));
        if (supported) Supported();
        else if (Vertical != CharacterAction.Jump) { Vertical = CharacterAction.Fall; ApplyGravity(); }

        if (Invulnerable > 0) Invulnerable--;
        _shootingCooldown--;
    }

    public void CollideWith(Character enemy)
    {
        if (_attacking > 0)
        {
            if (enemy.Invulnerable == 0) { enemy.TakeHit(Damage); enemy.CollisionPushback(this); }
        }
        else
        {
            if (Invulnerable == 0) { CollisionPushback(enemy); TakeHit(enemy.Damage); }
        }
    }

    public override void Die()
    {
        Invulnerable = int.MaxValue;
        Env.DyingAnimationGroup.Add(new DyingAnimation(Rect, isPlayer: true, endSound: HeroDeathSound));
        Kill();
    }

    public void ChangeRooms(Environment env, (int col, int row) position)
    {
        Env = env;
        var tileRect = env.RectForTile(position.col, position.row);
        float left = tileRect.Left() - (Facing == Direction.Left ? HitboxLeftOffset : HitboxRightOffset);
        Rect = new Rectangle(left, tileRect.Top(), Width, Height);
    }
}
```

**Step 2: Build and commit**

```bash
dotnet build src
git commit -am "feat: add Hero player character"
```

---

## Task 16: Powerup.cs

**Files:**
- Replace stub: `worldtree-raylib/src/characters/Powerups.cs`

Port of `worldtree/characters/powerup.py`.

**Step 1: Replace stub with full implementation**

The key difference from Python: `PickUp` no longer needs to modify `map_data` dicts for `cleanup=true` items (since C# loads from JSON at room load time, rooms are reconstructed on game-over restart, so permanent removal is not needed for the port).

```csharp
// src/characters/Powerups.cs
using Raylib_cs;

namespace WorldTree;

public abstract class Powerup
{
    public Rectangle Rect;
    public bool IsDead { get; protected set; }
    protected Environment Env;
    private readonly bool _oneTime;
    private static Sound? _itemGetSound;
    protected static Sound ItemGetSound =>
        _itemGetSound ??= Raylib.LoadSound("media/music/item_get.ogg");

    protected Powerup(Environment env, (int col, int row) position, bool oneTime = true)
    {
        Env = env;
        _oneTime = oneTime;
        var tileRect = env.RectForTile(position.col, position.row);
        Rect = new Rectangle(tileRect.X, tileRect.Y, 48, 48);
        InitImages();
    }

    protected virtual void InitImages() { }
    public virtual void Update() { }

    public Rectangle Hitbox() =>
        new Rectangle(Rect.X + 3, Rect.Y + 3, Rect.Width - 6, Rect.Height - 6);

    public void PickUp(Hero player)
    {
        Use(player);
        if (_oneTime) IsDead = true;
    }

    protected abstract void Use(Hero player);

    public virtual void Draw() { } // most powerups draw their texture here
}

public static class Powerups
{
    public class HealthBoost : Powerup
    {
        private static Texture2D[]? _imgs;
        private Animation<Texture2D> _anim;
        private static Texture2D[] Imgs => _imgs ??=
            TextureCache.LoadImages("lifeup*.png", scaled: true, colorkey: true);

        public HealthBoost(Environment env, (int, int) pos) : base(env, pos, oneTime: true)
        { _anim = new Animation<Texture2D>(Imgs, frameDelay: 1); }

        protected override void InitImages() { }
        public override void Update() { }
        protected override void Use(Hero p) { p.RaiseMaxHp(5); Raylib.PlaySound(ItemGetSound); }
        public override void Draw() =>
            Raylib.DrawTexture(_anim.NextFrame(), (int)Rect.X, (int)Rect.Y, Color.White);
    }

    public class HealthRestore : Powerup
    {
        private static Texture2D[]? _imgs;
        private Animation<Texture2D> _anim;
        private static Texture2D[] Imgs => _imgs ??=
            TextureCache.LoadImages("healthrestore*.png", scaled: true, colorkey: true);

        public HealthRestore(Environment env, (int, int) pos) : base(env, pos)
        { _anim = new Animation<Texture2D>(Imgs, frameDelay: 1); }

        protected override void InitImages() { }
        public override void Update() { }
        protected override void Use(Hero p) => p.RecoverHealth(3);
        public override void Draw() =>
            Raylib.DrawTexture(_anim.NextFrame(), (int)Rect.X, (int)Rect.Y, Color.White);
    }

    public class DoubleJump : Powerup
    {
        public DoubleJump(Environment env, (int, int) pos) : base(env, pos, oneTime: true) { }
        protected override void Use(Hero p) { p.MaxJumps = 2; Raylib.PlaySound(ItemGetSound); }
    }

    public class MoreSeeds : Powerup
    {
        private static Texture2D[]? _imgs;
        private Animation<Texture2D> _anim;
        private static Texture2D[] Imgs => _imgs ??=
            TextureCache.LoadImages("ammoup*.png", scaled: true, colorkey: true);

        public MoreSeeds(Environment env, (int, int) pos) : base(env, pos, oneTime: true)
        { _anim = new Animation<Texture2D>(Imgs, frameDelay: 1); }

        protected override void InitImages() { }
        public override void Update() { }
        protected override void Use(Hero p)
        {
            p.MaxAmmo += 2;
            p.Ammo = Math.Min(p.MaxAmmo, p.Ammo + 2);
            Raylib.PlaySound(ItemGetSound);
        }
        public override void Draw() =>
            Raylib.DrawTexture(_anim.NextFrame(), (int)Rect.X, (int)Rect.Y, Color.White);
    }

    public class AmmoRestore : Powerup
    {
        private static Texture2D[]? _imgs;
        private Animation<Texture2D> _anim;
        private static Texture2D[] Imgs => _imgs ??=
            TextureCache.LoadImages("seedammo*.png", scaled: true, colorkey: true);

        public AmmoRestore(Environment env, (int, int) pos) : base(env, pos)
        { _anim = new Animation<Texture2D>(Imgs, frameDelay: 1); }

        protected override void InitImages() { }
        public override void Update() { }
        protected override void Use(Hero p) => p.Ammo = Math.Min(p.MaxAmmo, p.Ammo + 2);
        public override void Draw() =>
            Raylib.DrawTexture(_anim.NextFrame(), (int)Rect.X, (int)Rect.Y, Color.White);
    }

    public class Lava : Powerup
    {
        private const int LavaDamage = 2;
        public Lava(Environment env, (int col, int row) pos, int widthInTiles)
            : base(env, pos, oneTime: false)
        {
            Rect = Rect.WithSize(widthInTiles * GameConstants.TileWidth, GameConstants.TileHeight);
        }
        protected override void Use(Hero p) { if (p.Invulnerable == 0) p.TakeHit(LavaDamage); }
    }

    public class Spike : Powerup
    {
        private const int SpikeDamage = 2;
        private const float SpikePushback = 32f;
        public Spike(Environment env, (int col, int row) pos, int widthInTiles)
            : base(env, pos, oneTime: false)
        {
            Rect = Rect.WithSize(widthInTiles * GameConstants.TileWidth, GameConstants.TileHeight);
        }
        protected override void Use(Hero p)
        {
            if (p.Invulnerable == 0) { p.CollisionPushback(new SpikeProxy(Rect)); p.TakeHit(SpikeDamage); }
        }

        // Minimal proxy so CollisionPushback can use Spike's rect
        private class SpikeProxy : Character
        {
            public SpikeProxy(Rectangle r) : base(null!, (0, 0)) { Rect = r; }
            public override float PushBack => SpikePushback;
            protected override void InitImages() { }
            protected override void SetCurrentImage() { }
            protected override (float, float) GetMove() => (0, 0);
        }
    }
}
```

**Step 2: Build and commit**

```bash
dotnet build src
git commit -am "feat: add Powerup classes"
```

---

## Task 17: Enemies.cs

**Files:**
- Replace stub: `worldtree-raylib/src/characters/Enemies.cs`

Port of `worldtree/characters/enemies.py`. 11 enemy types.

**Step 1: Implement all enemies** (this is the longest single task — ~500 lines)

Implement the full `Enemies.cs` file with all 11 classes following the same pattern as the Python. Key notes:
- All Python `pygame.transform.flip()` calls → `TextureCache.FlipHorizontal()`
- All `self.rect` references are in world coords
- `SenseAndReturnHitbox` receives the `Hero` and may update enemy AI state
- `BugPipe`/`BiterPipe` `IsScreenCoordinateVisible` → `Env.IsWorldPointVisible(Rect.CenterX(), Rect.Top())`
- `Baron.Die()` uses `DyingAnimation` with `isBoss: true` and win sound

Complete implementation: port each class from `enemies.py` in order: `Beaver`, `Dragonfly`, `BoomBug`, `Shooter`, `PipeBug`, `BugPipe`, `Biter`, `BiterPipe`, `Batzor`, `Slug`, `Baron`.

For each class keep the same constants, `GetMove()`, `SenseAndReturnHitbox()`, and `Update()` logic. Use `TextureCache.LoadImages()` and `TextureCache.FlipHorizontal()` in place of `character.LoadImages()` and `pygame.transform.flip()`.

**Step 2: Build and fix any compilation errors**

```bash
dotnet build src
```

**Step 3: Commit**

```bash
git commit -am "feat: add all 11 enemy types"
```

---

## Task 18: Statusbar.cs

**Files:**
- Create: `worldtree-raylib/src/Statusbar.cs`

Port of `worldtree/statusbar.py`. Drawn in screen space (outside BeginMode2D).

**Step 1: Implement Statusbar.cs**

```csharp
// src/Statusbar.cs
using Raylib_cs;
using System.Numerics;

namespace WorldTree;

public class Statusbar
{
    private static readonly Dictionary<string, string> RegionNames = new()
    {
        { "photosynthesis.ogg", "High Branches"    },
        { "foreboding_cave.ogg","Ruins of Asgard"  },
        { "nighttime.ogg",      "Inside the Trunk" },
        { "ozor.ogg",           "Star Caves"       },
        { "bongo_wip.ogg",      "The Baron's Lair" },
    };

    private Font _font;
    private Hero _player;

    public Statusbar(Hero player)
    {
        _player = player;
        _font = Raylib.LoadFont(Path.Combine(GameConstants.FontDir, GameConstants.Font));
    }

    /// <summary>
    /// Draw the HUD. Call this OUTSIDE BeginMode2D so coordinates are screen-relative.
    /// </summary>
    public void Draw()
    {
        // Black background strip
        Raylib.DrawRectangle(0, 0, GameConstants.ScreenWidth, GameConstants.MapY, Color.Black);

        string hpText = $"Health: {_player.Hp}/{_player.MaxHp}";
        Raylib.DrawTextEx(_font, hpText, new Vector2(10, 10), 24, 1, Color.White);

        if (_player.MaxAmmo > 0)
        {
            string ammoText = $"Seeds: {_player.Ammo}/{_player.MaxAmmo}";
            Raylib.DrawTextEx(_font, ammoText, new Vector2(10, 45), 24, 1, Color.White);
        }

        if (Environment.SongsByRoom.TryGetValue(_player.Env.Region, out var songs)
            && songs.TryGetValue(_player.Env.Name, out var song)
            && RegionNames.TryGetValue(song, out var regionName))
        {
            var size = Raylib.MeasureTextEx(_font, regionName, 24, 1);
            Raylib.DrawTextEx(_font, regionName,
                new Vector2(GameConstants.ScreenWidth - 10 - size.X, 10), 24, 1, Color.White);
        }

        string roomText = $"Room {_player.Env.Name[3..]}";
        var roomSize = Raylib.MeasureTextEx(_font, roomText, 24, 1);
        Raylib.DrawTextEx(_font, roomText,
            new Vector2(GameConstants.ScreenWidth - 10 - roomSize.X, 45), 24, 1, Color.White);
    }
}
```

**Step 2: Build and commit**

```bash
dotnet build src
git commit -am "feat: add Statusbar HUD"
```

---

## Task 19: TitleScreen.cs

**Files:**
- Create: `worldtree-raylib/src/TitleScreen.cs`

Port of `worldtree/titlescreen.py`.

**Step 1: Implement TitleScreen.cs**

```csharp
// src/TitleScreen.cs
using Raylib_cs;
using System.Numerics;

namespace WorldTree;

public class TitleScreen
{
    private static readonly string IntroText = """

        The World Tree, source of all
        life...
        ...
        """; // (copy full text from titlescreen.py)

    private static readonly string ControlsText = """

        CONTROLS


        Arrow keys or WASD - move

        Space bar - jump

        M - attack

        N - shoot (requires ammo)

        Return - start
        """;

    private static readonly string CreditsText = """

        You have defeated the Beaver
        Baron and brought peace to
        the World Tree.
        ...
        """; // (copy full text from titlescreen.py)

    private Font _font;
    private Texture2D? _background;
    private string _text;
    private int _textSpeed;
    private int _fadeRate;
    private int _frameDelay;
    private MusicStream? _music;

    public TitleScreen(string text, int textSpeed = 4, int fadeRate = 4,
                       int frameDelay = 0, Texture2D? background = null, string? musicFile = null)
    {
        _font = Raylib.LoadFont(Path.Combine(GameConstants.FontDir, GameConstants.Font));
        _text = text;
        _textSpeed = textSpeed;
        _fadeRate = fadeRate;
        _frameDelay = frameDelay;
        _background = background;
        if (musicFile != null)
        {
            _music = Raylib.LoadMusicStream(Path.Combine(GameConstants.MusicDir, musicFile));
            Raylib.PlayMusicStream(_music.Value);
        }
    }

    /// <summary>Show this screen until the player presses Enter. Returns when done.</summary>
    public void Show()
    {
        int frame = -_frameDelay;
        var lines = _text.Split('\n');
        var textArray = new List<string>();
        const int fontHeight = 16;
        const int lineHeight = 20;
        const int textTop = 144;
        const int textBottom = 576;

        while (!Raylib.WindowShouldClose())
        {
            if (_music.HasValue) Raylib.UpdateMusicStream(_music.Value);
            bool startPressed = Raylib.IsKeyDown(KeyboardKey.Enter);
            bool canExit = startPressed && (frame + _frameDelay) >= 30;

            Raylib.BeginDrawing();
            Raylib.ClearBackground(Color.Black);

            if (_background.HasValue)
                Raylib.DrawTexture(_background.Value, 0, 0, Color.White);

            if (frame >= 0)
            {
                float textPos = textBottom - frame / (float)_textSpeed;
                int lineIdx = frame / (_textSpeed * lineHeight);
                if (frame % (_textSpeed * lineHeight) == 0 && lineIdx < lines.Length)
                    textArray.Add(lines[lineIdx]);

                for (int i = 0; i < textArray.Count; i++)
                {
                    float y = textPos + i * lineHeight;
                    var size = Raylib.MeasureTextEx(_font, textArray[i], fontHeight, 1);
                    Raylib.DrawTextEx(_font, textArray[i],
                        new Vector2(480 - size.X / 2f, y), fontHeight, 1, Color.White);
                }
            }

            Raylib.EndDrawing();

            if (canExit) break;
            frame++;
        }

        if (_music.HasValue) Raylib.StopMusicStream(_music.Value);

        // Fade out
        if (_background.HasValue)
        {
            int fadeFrame = 0;
            while (!Raylib.WindowShouldClose())
            {
                int alpha = 255 - fadeFrame * _fadeRate;
                if (alpha <= 4) break;
                fadeFrame++;
                Raylib.BeginDrawing();
                Raylib.ClearBackground(Color.Black);
                Raylib.DrawTexture(_background.Value, 0, 0, new Color(255, 255, 255, (byte)alpha));
                Raylib.EndDrawing();
            }
        }

        if (_music.HasValue) Raylib.UnloadMusicStream(_music.Value);
    }

    public static void ShowTitle()
    {
        var bg = Raylib.LoadTexture(Path.Combine("media", "titlescreen.png"));
        new TitleScreen(IntroText, background: bg, musicFile: "june_breeze.ogg",
                        textSpeed: 4, frameDelay: 120).Show();
        Raylib.UnloadTexture(bg);
        new TitleScreen(ControlsText, textSpeed: 1, fadeRate: 12).Show();
    }

    public static void ShowCredits()
    {
        new TitleScreen(CreditsText, musicFile: "june_breeze_2.ogg", textSpeed: 2).Show();
    }
}
```

**Step 2: Build and commit**

```bash
dotnet build src
git commit -am "feat: add TitleScreen"
```

---

## Task 20: Program.cs — Game Loop

**Files:**
- Replace: `worldtree-raylib/src/Program.cs`

Port of `worldtree/worldtree.py`. The main game loop with collision detection, room transitions, audio, and game state.

**Step 1: Load static data (call once at startup, before RunGame)**

```csharp
// Top of Program.cs — load maps and config data, set up Environment statics

var allMaps1 = MapLoader.LoadRegion("data/map_data.json");
var allMaps2 = MapLoader.LoadRegion("data/map_data2.json");
Environment.Regions[1] = allMaps1;
Environment.Regions[2] = allMaps2;
var allTransitions = MapLoader.LoadTransitions("data/map_transitions.json");

// Music config — mirrors SONGS and BG_COLORS in environment.py
// ... (build SongsByRoom and BgColorsByRoom dicts, same structure as Python)
Environment.SongsByRoom = BuildSongsByRoom();
Environment.BgColorsByRoom = BuildBgColorsByRoom();
```

**Step 2: Implement RunGame() and room transition logic**

```csharp
// Full Program.cs

using Raylib_cs;
using System.Numerics;
using WorldTree;

// Working directory: dotnet run sets this to the project dir automatically
Raylib.InitWindow(GameConstants.ScreenWidth, GameConstants.ScreenHeight, GameConstants.GameName);
Raylib.InitAudioDevice();
Raylib.SetTargetFPS(60);

LoadStaticData();

while (!Raylib.WindowShouldClose())
{
    try { RunGame(); } catch { /* game over — restart */ }
}

Raylib.CloseAudioDevice();
Raylib.CloseWindow();

// ---- local functions ----

void RunGame()
{
    TitleScreen.ShowTitle();

    string currentRoom = "Map1";
    int currentRegion = 1;
    var env = new Environment(currentRoom, currentRegion);
    var player = new Hero(env, (2, 10));
    var statusbar = new Statusbar(player);
    var camera = env.MakeCamera();
    var gameState = GameState.Playing;

    MusicStream? currentMusic = default;
    string? currentSong = null;
    currentSong = TryStartMusic(env, ref currentMusic, null);

    while (!Raylib.WindowShouldClose() && gameState == GameState.Playing)
    {
        if (currentMusic.HasValue) Raylib.UpdateMusicStream(currentMusic.Value);

        // --- Update ---
        player.HandleInput();

        // Sprite-vs-enemy collision
        foreach (var enemy in env.EnemyGroup.Where(e => !e.IsDead))
        {
            bool hit = Raylib.CheckCollisionRecs(player.Hitbox(),
                           enemy.SenseAndReturnHitbox != null
                               ? enemy.SenseAndReturnHitbox(player)
                               : enemy.Hitbox());
            if (hit) player.CollideWith(enemy);
        }

        // Item pickup
        foreach (var item in env.ItemGroup.Where(i => !i.IsDead))
            if (Raylib.CheckCollisionRecs(player.Hitbox(), item.Hitbox()))
                item.PickUp(player);

        // Hero projectile vs enemies
        foreach (var bullet in env.HeroProjectileGroup.Where(b => !b.IsDead))
            foreach (var enemy in env.EnemyGroup.Where(e => !e.IsDead))
                if (Raylib.CheckCollisionRecs(bullet.Rect, enemy.Hitbox()))
                { bullet.CollideWith(enemy); bullet.IsDead = true; }

        // Enemy projectiles vs player
        foreach (var bullet in env.EnemyProjectileGroup.Where(b => !b.IsDead))
            if (Raylib.CheckCollisionRecs(bullet.Rect, player.Hitbox()))
            { bullet.CollideWith(player); bullet.IsDead = true; }

        player.Update();
        camera = env.Scroll(camera, player.Fallbox());

        foreach (var e in env.EnemyGroup)      e.Update();
        foreach (var i in env.ItemGroup)        i.Update();
        foreach (var b in env.HeroProjectileGroup)  b.Update();
        foreach (var b in env.EnemyProjectileGroup) b.Update();

        foreach (var d in env.DyingAnimationGroup)
        {
            var state = d.Update();
            if (state == GameState.Won) { TitleScreen.ShowCredits(); gameState = GameState.GameOver; }
            else if (state == GameState.GameOver) gameState = GameState.GameOver;
        }

        // Remove dead entities
        env.EnemyGroup.RemoveAll(e => e.IsDead);
        env.ItemGroup.RemoveAll(i => i.IsDead);
        env.HeroProjectileGroup.RemoveAll(b => b.IsDead);
        env.EnemyProjectileGroup.RemoveAll(b => b.IsDead);
        env.DyingAnimationGroup.RemoveAll(d => d.IsDead);

        // --- Draw ---
        Raylib.BeginDrawing();
        Raylib.ClearBackground(env.BgColor);

        Raylib.BeginMode2D(camera);
        env.DrawTiles();
        foreach (var i in env.ItemGroup)    i.Draw();
        foreach (var e in env.EnemyGroup)   e.Draw();
        foreach (var b in env.HeroProjectileGroup)  b.Draw();
        foreach (var b in env.EnemyProjectileGroup) b.Draw();
        foreach (var d in env.DyingAnimationGroup)  d.Draw();
        if (!player.IsDead) player.Draw();
        Raylib.EndMode2D();

        statusbar.Draw(); // screen-space HUD

        if (gameState == GameState.GameOver)
        {
            var font = Raylib.LoadFont(Path.Combine(GameConstants.FontDir, GameConstants.Font));
            var text = "Game Over";
            var size = Raylib.MeasureTextEx(font, text, 24, 1);
            Raylib.DrawTextEx(font, text,
                new Vector2(GameConstants.ScreenWidth / 2f - size.X / 2f,
                            GameConstants.ScreenHeight / 2f - size.Y / 2f),
                24, 1, Color.White);
        }

        Raylib.EndDrawing();

        // --- Room transitions ---
        if (env.IsOutsideMap(player.Fallbox()))
            HandleRoomTransition(ref env, ref player, ref camera, ref currentRoom,
                                 ref currentRegion, ref currentSong, ref currentMusic,
                                 allTransitions);
    }

    if (currentMusic.HasValue) Raylib.StopMusicStream(currentMusic.Value);
}
```

Room transition logic (`HandleRoomTransition`) mirrors `worldtree.py` lines 126-193 exactly.

**Step 2: Build and run**

```bash
cd /home/dscotton/src/worldtree_repo/worldtree-raylib
dotnet build src
dotnet run --project src
```
Expected: Title screen appears, then game starts with player in Map1.

**Step 3: Smoke test**
- Player spawns and falls onto the ground
- Player can walk left and right
- Player can jump
- Enemies are visible and move

**Step 4: Commit**

```bash
cd /home/dscotton/src/worldtree_repo
git commit -am "feat: implement main game loop with room transitions"
```

---

## Task 21: Final Integration Pass

**Files:**
- Various (audio wiring, edge cases)

**Step 1: Verify audio**
- Music plays on entering each room
- Music fades when changing rooms
- SFX plays on jump, attack, hit, death

**Step 2: Verify room transitions**
- Walk off each edge of Map1 — player should appear in the correct adjacent room
- Screen offset should be set correctly on arrival

**Step 3: Verify all enemy types load and behave**
- Visit map rooms that contain each enemy type
- Check game constants for specific rooms with each type (see `environment.py` ENEMIES dict)

**Step 4: Verify powerups**
- HealthBoost in map (region 1 mapcodes 129-131)
- DoubleJump and MoreSeeds work correctly
- Drop items from defeated enemies

**Step 5: Verify game over and restart**
- Let player die — Game Over screen appears, game restarts at title screen

**Step 6: Verify win condition**
- The Baron is in region 2 (mapcode 11)
- Defeating the Baron shows credits then restarts

**Step 7: Commit**

```bash
git commit -am "fix: integration pass — audio, transitions, all enemy types verified"
```

---

## Summary

| Task | Component | Tests |
|------|-----------|-------|
| 1  | Project scaffold | Build check |
| 2  | Media symlink | File existence |
| 3  | Map JSON conversion | JSON structure |
| 4  | GameConstants | Build check |
| 5  | RectangleExtensions | Unit tests ✓ |
| 6  | Tile / ParseBoundByte | Unit tests ✓ |
| 7  | Animation | Unit tests ✓ |
| 8  | MapLoader | Unit tests ✓ |
| 9  | TextureCache / Controller | Build check |
| 10 | Environment (construction) | Build check |
| 11 | Environment (camera/render) | Visual |
| 12 | Environment (collision) | Visual |
| 13 | Character base | Build check |
| 14 | Projectile | Visual |
| 15 | Hero | Visual |
| 16 | Powerups | Visual |
| 17 | Enemies (all 11) | Visual |
| 18 | Statusbar | Visual |
| 19 | TitleScreen | Visual |
| 20 | Program / game loop | Full play-through |
| 21 | Integration pass | All systems verified |
